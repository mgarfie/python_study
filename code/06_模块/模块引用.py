
# #-----------------------------此方法是把模块中的所有都调用过来使用的，但有时候只是用此模块中的一个功能---------------------------
# import time         #引入使用python内置的模块，可以用ctrl点击模块名字打开此模块
# print("你好1")
# time.sleep(3)               #程序在这里等待3s以后在执行下面的语句 当中的.可以调用内部的功能
# print("你好2")
# #----------------------------单独调用模块中的一个功能-----------------------------------------
# from time import sleep
# print("你好1")
# sleep(3)               #同上，不同的是不用time父目录了
# print("你好2")
# #--------------------------------全部功能---------------------------------------
# from time import *
# print("你好1")
# sleep(3)              #同上
# print("你好2")
# #-------------------------------------某个功能导入以后设置别名----------------------
# from time import sleep as sm
# print("你好1")
# sm(3)               #同上
# print("你好2")
# #------------------------------导入自定义模块------------------------------------
# from my_module1 import*
# test(1,1)
# #--------------------------------当有两个模块，但是方法名称一样时的情况----------------------------
# from my_module1 import*
# from my_module2 import*
# test(1,1)                                       #运行结果为0，是因为my_module2里是两个数相减的，所以就是my_module2把my_module1给顶替掉了，只运行了my_module2


#---------------------------------------__main__函数---------------------------------------------

from my_module3 import*             #此时发现，调用模块以后，没进行操作但是会打印数字，这是因为在from my_module3时，本质上说已经把my_module3给执行了一遍

                                    #为了解决此方法，可以调用python中内置的一个main变量。格式如下
                                                    #if __name__=='__main__':
test(1,1)
                                    #main变量，在程序手动运行（不是调用）时，__name__变量会变成__main__变量，反之则不会

#-----------------------------------------__all__函数-------------------------------------
                                                #如果一个模块文件中有__all__变量，当使用from xxx impor*导入时，只能导入这个列表中的元素
from my_module3 import*
test2                                       #此时，test2就已经开始报错了，说test2 is not，就是没有的意思，但是my_module3里确实是有这个的，因此，就是__all__的使用方法                                                